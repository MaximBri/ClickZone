ClickZone

ClickZone - увлекательная онлайн-игра, где тебе предстоит кликать, зарабатывать монеты, соревноваться с другими игроками.

Твоя основная задача - кликать на фигурку. Со временем она будет улучшаться, пока не станет максимальной.

![](https://fs.cr5.space/file/p-LJ2cPxni/0cdeb2f0-4347-4f9a-8d19-8d11596d5f60 'image-d1603d9c-a93c-42fb-8383-94424eb6a134.png
Клик, чтобы открыть
Ctrl+Клик, чтобы скачать')

В игре есть 2 валюты: монеты и алмазы. За них ты можешь покупать различные улучшения, которые будут ускорять прокачку, контейнеры, из них может выпасть что-то ценное.

Для кликера есть множество улучшений: как одноразовых, так и бесконечных. Они помогут тебе быстрее прокачиваться и зарабатывать больше монет.

![](https://fs.cr5.space/file/p-LJ2cPxni/318b8127-1e6c-455f-a651-fc74e4375569 'image-fc369166-e2ac-40bc-82fc-06c7975afe19.png
Клик, чтобы открыть
Ctrl+Клик, чтобы скачать')

Для сохранения всего прогресса вам необходимо зарегистрироваться. Это открывает массу новых возможностей: сохранение всего прогресса, доступ к магазину улучшений и контейнеров, возможность получения ежедневных наград и достижений.

![](https://fs.cr5.space/file/p-LJ2cPxni/06ce925a-ca50-497a-9674-b5a897f1c9d9 'image-688cb15d-492b-4e5f-bb5a-4df4a98781cc.png
Клик, чтобы открыть
Ctrl+Клик, чтобы скачать')

![](https://fs.cr5.space/file/p-LJ2cPxni/14ddda60-32e7-4f2a-887e-eac44af9f270 'image-ff5f3f64-d2ea-44af-9c0b-907454eb4bd1.png
Клик, чтобы открыть
Ctrl+Клик, чтобы скачать')

У каждого зарегистрированного пользователя есть личный кабинет, где он может указать некоторую информацию о себе: выбрать уникальный никнейм и установить своё описание. Помимо этого там можно посмотреть достижения, дату регистрации. Там же находится кнопка выхода из аккаунта.

![](https://fs.cr5.space/file/p-LJ2cPxni/4e7057c5-5e17-407e-95ef-60d059467166 'image-8cecfcff-11f5-4e09-be3a-470364bd6043.png
Клик, чтобы открыть
Ctrl+Клик, чтобы скачать')

# ДОКУМЕНТАЦИЯ

# ФРОНТЕНД:

# Глобальная установка Frontend-зависимостей:

Чтобы установить все необходимые зависимости, в терминале/командной строке необходимо из папки `client` (переход в неё можно осуществить через команду `cd client`, если находитесь в корне проекта) достаточно запустить команду

```Node.js
npm intall
```

или её более короткий вариант:

```Node.js
npm i
```

Дальше нужно будет подождать, пока все зависимости установятся. Если всё прошло успешно, в папке `client` должна создаться папка `node_modules`, в ней хранятся все установленные зависимости.

Главный файл, который хранит в себе все необходимые зависимости - `package.json`. Он является обязательным для установки всех необходимых зависимостей. Есть более подробная его версия - `package-lock.json`. Если в `package.json` зависимости сгруппированы, то в `package-json` все они расписаны индивидуально.

Если сделали установку через `npm install`, то дальше устанавливать новые зависимости не имеет смысла (можно переходить к следующему пункту).

# Установка основных зависимостей:

## Установка Node.js и npm:

### Введение

**Node.js** — среда выполнения JavaScript на стороне сервера.

**npm** (Node Package Manager) — менеджер пакетов для установки библиотек и инструментов.
Для проектов на TypeScript они необходимы:

- Компиляция TypeScript в JavaScript.
- Управление зависимостями (например, Phaser.js для игр).

### Скачивание установщика:

1. Перейдите на [официальный сайт Node.js.](https://nodejs.org/);
2. Выберите LTS-версию (рекомендуется для стабильности).

### Установка:

1. Запустите скачанный файл (.msi для Windows, .pkg для macOS).
2. Следуйте инструкциям мастера установки (оставьте настройки по умолчанию).
3. Убедитесь, что опция npm включена.

### Проверка установки

Если всё установилось успешно, то откройте терминал/командную строку и выполните:

```bash
node -v
npm -v
```

Должны отобразиться версии (например, `v18.16.0` для `Node.js` и `9.5.1` для `npm`)

## Установка TypeScript:

Для глобальной установки `TypeScript` используйте команду

```javascript
npm install -g typescript
```

из папки `client`. Если требуется установить все зависимости локально, то запустите ту же команду без флага `-g`:

```javascript
npm install typescript
```

В случае успешной установки выполните команду

```
tsc -v
```

Должна вывестись версия `TypeScript`.

## Установка SCSS:

Для глобальной установки Sass (компилятора SCSS) используйте команду

```
npm install -g sass
```

из папки client. Если требуется установить все зависимости локально (рекомендуется для большинства проектов), то запустите ту же команду без флага -g:

```
npm install sass
```

После успешной установки вы можете проверить версию Sass командой:

```
sass --version
```

Должна вывестись версия установленного Sass.

## Установка React

Для создания нового проекта на React используйте команду:

```
npx create-react-app my-app
```

или, если вы используете `TypeScript`:

```
npx create-react-app my-app --template typescript
```

Если проект уже создан, установите React и ReactDOM локально:

```
npm install react react-dom
```

Проверьте успешную установку, выполнив:

```
npm list react
```

Должна отобразиться установленная версия `React`.

## Установка Redux Toolkit

Для добавления `Redux Toolkit` и интеграции с `React` используйте команду:

```
npm install @reduxjs/toolkit react-redux
```

Проверьте успешную установку, выполнив:

```
npm list @reduxjs/toolkit
```

Должна отобразиться установленная версия `Redux Toolkit`.

# Документация по проекту:

Представлена в виде слоёв (как то подразумевает применяемая в проекте архитектура `FSD`).

## App-слой (слой приложения):

Предназначен для общих компонентов приложения. В него входят:

- Основной слой приложения (общая часть для всех страниц)
- Роутинг (пути к страницам приложениям)
- Локальное хранилище (Redux-toolkit, нужно для избежания повторных запросов на бэкенд, если данные уже были когда-либо запрошены в рамках текущей вкладки браузера)
- Глобальные стили приложения, переменные (CSS)

### Папка `layout`:

Отвечает за общий шаблон приложения, на который опираются все страницы приложения. Содержит в себе:

- Футер (подвал сайта)
- Хэдер (шапка сайта)
- Боковую панель (navbar)
- Портал. Нужен для "выноса" всплывающих окон на более высокий уровень `DOM-дерева` страницы. Это является признаком хорошего тона.
- Сам слой (`MainLayout.tsx`)

### Папка `routes`:

Содержит в себе все компонент с настройкой путей и компонентов для каждой из страниц. Все пути приложения вынесены в отдельный файл (`/client/src/shared/config/routes.ts`), это тоже является хорошей практикой. Если нужно будет поменять пути к страницам, нужно будет поменять их в одном файле, а не искать их по всему проекту.

### Папка `store`:

Содержит в себе подключение всех локальных фронтенд-хранилищ `Redux-toolkit`, чтобы можно было взять информацию из них в любом компоненте.

Хранилища используются для того, чтобы не прокидывать параметры через много компонентов (библиотека `React` подразумевает компонентно-ориентированный подход разработки, когда всё приложение разбивается на множественные самостоятельные компоненты), а доставать их напрямую из хранилища там, где это нужно. Кроме этого, хранилища сохраняют данные при переходе на другие страницы внутри приложения. Это позволяет не слать повторные запросы на бэкенд, если этот запрос уже был выполнен и данные сохранились.

Основная цель хранилищ - удобство использования глобальных данных приложения и оптимизация запросов к бэкенду, что тоже является хорошим тоном.

### Папка `styles`:

Содержит в себе:

- CSS стили приложения в целом, в том числе стилизация основного шаблона приложения (`globals.scss`).
- Файл сброса стилей браузеров (`reset.scss`). Необходим для кроссбраузерности сайта, т.е. чтобы он выглядел одинаково во всех браузерах
- Файл подключения шрифтов (`fonts.scss`)
- Файл с общими CSS переменными (`_variables.scss`), нужен для удобства настройки цветовой гаммы приложения. Если нужно будет поменять какой-либо цвет, его нужно будет поменять только в этом файле и нигде больше.
- Файл с шаблонами кода (`_mixins.scss`)
- Файл с подключением всех стилей в одном файле (`index.scss`). Объединяет в себе все файлы через импорты. Это позволяет подключить только один файл, чтобы все файлы scss подключились, вместо множественного подключения (по отдельности каждый файл).

### Файл `main.tsx`:

Главный файл приложения, который подключается непосредственно к `html` файлу. Он "тянет" за собой всё приложение.

### Файл `App.tsx`:

Содержит в себе подключение хранилища и роутинга (компонентами)

### Файл `mainLayoutModel.ts`:

Содержит в себе общую логику всего приложения.
Из хранилища достаются следующие данные:

- Авторизирован ли пользователь
- Загружены ли данные о кликере (флаг)
- Дата регистрации пользователя (для начисления награды "Легионер", если прошло 30 дней с момента регистрации)
- Загружены ли данные пользователя (флаг)

Запрашивается данные о кликере. Если пользователь авторизован, то все данные будут установлены в хранилище, далее пойдут запросы на получение массива ежедневных наград и статус ежедневной награды (приходит количество часов, через сколько можно забрать ежедневную награду, возможность прямо сейчас забрать награду)

Если у пользователя количество монет в минуту не нулевое, то запускается автокликер.

Если у пользователя прошло 30 дней с момента регистрации, начисляется награда "Первооткрыватель".

При изменении количества монет проверяется их количество и выдаются соответствующие награды (Новичок, Миллионер, Магнат)

Подключёны модули:

1. Модуль, отвечающий за отправку запроса на синхронизацию ресурсов в момент закрытия вкладки
2. Модуль по повторной отправке запросов, провалившихся с 401 ошибкой (не авторизирован). Если какой-либо запрос пришёл с 401-й ошибкой, будет автоматически отправлен запрос на обновление JWT access токена и провалившийся с ошибкой запрос будет отправлен повторно. В рассмотрение берутся все запросы, кроме авторизации и регистрации (они не требуют проверки JWT access токена, именно он может быть источником 401-й ошибки).

## Pages-слой (слой страниц):

Включает в себя все страницы приложения:

1. **Главная**.

На ней находится фигурка, по которой пользователь должен кликать. Там же можно купить различные улучшения к кликеру. Отображается количество монет за клик и количество монет в минуту.

2. **Личный кабинет пользователя**

Там представлена вся основная информация о зарегистрированном пользователе:

- Никнейм
- Описание
- Награды
- Дата регистрации

Никнейм и описание можно менять. Описание меняется всегда бесплатно, за смену никнейма нужно платить 100 монет, но первый раз можно сменить никнейм бесплатно.

3. **"Рандомайзер"**

В нём можно покупать контейнеры и ключи к ним, открывать контейнеры. Всего 5 видов различных контейнеров. Каждый вид контейнера имеет определённую цену в монетах или алмазах (можно купить за любую из этих внутриигровых валют), список того, что может выпасть: монеты, алмазы, контейнеры, улучшения.

4. **Ежедневные награды**

На этой странице отображается список всех наград и количество часов, через которое можно получить новую ежедневную награду.

5. **Страница контейнера**

Это страница с динамическим контентом. В ссылке передаётся `id` контейнера, по которому подтягивается вся информация о нём: из redux-хранилища (если в нём есть контейнер с таким `id`) или с бэкенда.

На странице отображается само изображение контейнера, кнопки с покупками и список того, что из него может выпасть.

6. **Страница пользователя**

На ней можно посмотреть информацию о других игроках: их никнейм, описание, достижения, дату регистрации

7. **Таблица лидеров**

На ней отображается топ-10 игроков по количеству монет или алмазам (можно регулировать)

### Главная страница (`/pages/home`):

Включает в себя 2 папки:

- `model`. Внутри содержит список с фигурками и их условие показа.
- `ui`. Содержит сам компонент страницы и стили к нему

Компонент страницы включает в себя ещё 4 компонента:

```
  <ProgressInfo /> - информация о количестве монет в минуту и за клик (показывается только в мобильной версии)
  <Animal /> - сам компонент фигурки
  <ClickerNavBar /> - боковое навигационное меню
  <InfinityMiglioramenti /> - список постоянных улучшений
```

### Личный кабинет пользователя (`/pages/account`):

Включает в себя папку `ui`, в ней находится сам компонент страницы и стили к нему.

#### Логика страницы:

Из хранилища достаются все необходимые данные о пользователе:

- Авторизован ли он (если нет, то перенаправление на главную страницу)
- Никнейм
- Описание
- Список наград
- Дата регистрации
- Может ли бесплатно поменять никнейм

Функция `sendRequestToChangeAccountData` отправляет запрос на сервер. В параметрах передаются новые данные пользователя (никнейм, описание).

Функция `saveNewUserData` определяет, что было изменено (никнейм/описание) и показывает нужное уведомление в правом нижнем углу

### Страница "Рандомайзер" (`/pages/randomizer`):

Включает в себя 2 папки:

- `model`. Внутри содержит локальное хранилище с контейнерами (слайс), модель (основная логика в виде функции, которая возвращает другие функции).
- `ui`. Содержит сам компонент страницы и стили к нему

#### Локальное хранилище контейнеров (`/pages/randomizer/model/containtersSlice.ts`)

Представляет собой объект со следующими полями:

- `data` - контейнеры, которые есть у пользователя
- `keys` - количество ключей
- `allContainers` - список всех контейнеров (запрашивается с бэкенда)
- `activeContainer` - контейнер, который пользователь открывает (или `null`, если не открывает)

Методы для обновления данных хранилища:

- **`addContainer`** - принимает в параметр контейнер, который нужно добавить пользователю (в результате покупки контейнера, какой-либо награды). В хранилище сначала ищется контейнер с таким же id среди тех, которые есть. Это связано с тем, что в хранилище контейнеры "стакаются", к ним приписывается ещё свойство `count`, отвечающее за количество контейнеров определённого вида. Если такой контейнер есть среди тех, которые уже есть у пользователя, то к тому контейнеру к `count` прибавляется 1, иначе в массив контейнеров пользователя добавляется новый объект - контейнер, который поступил в параметре со свойством `count` = 1.

- **`addContainerWithCount`** - принимает контейнер со свойством `count`, в остальном логика похожа на предыдущий метод. Тоже запускается поиск по контейнерам, которые есть у пользователя. Если контейнер с таким `id` уже есть, у него прибавляется `count`, иначе в массив добавляется тот контейнер, который пришёл в параметре

- **`setContainerKeys`** - принимает количество ключей и устанавливает его в хранилище.

- **`removeOneKey`** - вычитает из количества ключей пользователя 1

- **`removeOneContainer`** - убирает один контейнер (после открытия). Если после вычета контейнера поле count меньше 1, то этот элемент (контейнер) убирается из массива.

Кроме этого есть 3 "прослушки" на ответы от бэкенда:

- `getContainers` - устанавливает общий список контейнеров
- `fetchClickerData` и `loginUser` - устанавливают список контейнеров, которые есть у пользователя и количество купленных ключей.

#### Модель (логика, `randomizePageModel`):

Передаёт компоненту страницы все необходимые данные из хранилищ и запрашивает у бэкенда список контейнеров в случае, если его нет в хранилище.

### Страница ежедневных наград (`/pages/daily-rewards`):

Показывает награды за каждые из 14 дней, количество дней, когда награды уже были забраны, количество часов до следующей награды.

В папке `ui` содержится сам компонент страницы и стили к нему

#### Логика страницы:

Из хранилища достаются данные:

- Авторизован пользователь или нет
- Текущий день награды, которую пользователь сможет забрать
- Количество часов до новой ежедневной награды
- Массив улучшений
- Массив контейнеров

Если массив улучшений или контейнеров пуст, будет выполнен запрос на их получение и запись в хранилище.

Если массив ежедневных наград пуст или текущий день ещё не определён, то будет показано состояние загрузки.

### Страница контейнера (`/pages/container`):

Показывает информацию о конкретном контейнере:

- Название
- Изображение
- Цена за монеты и алмазы
- Список выпадаемых предметов (монеты, алмазы, улучшения, контейнеры)

#### Логика страницы:

Из `url` строки извлекается параметр - тип контейнера. Далее запрашивается общий список контейнеров из хранилища. Если он пуст, то выполняется запрос к бэкенду на его получение. Далее если список не пуст и контейнер с типом, который объявлен в `url` не найден, то пользователя перекинет на главную страницу.

### Страница пользователя (`/pages/user`):

Отвечает за отображение данных пользователя на основе id-параметра, который был передан в `url`.

#### Логика:

Сначала извлекается параметр `id` из `url`. Далее идёт запрос на бэкенд для получения информации о пользователе (вызывается функция `getUserInfo`). Пока данных не будет, будет показываться загрузка.

Функция `getUserInfo` выполняет запрос на бэкенд и устанавливает новые данные в компоненте.

Функция `formatDate` принимает на вход строку, которая преобразуется в дату формата `ДД.ММ.ГГГГ`. Используется для более понятного представления, т.к. с бэкенда дата приходит в формате `ISO 8601`.

### Страница Таблицы лидеров:

Отвечает за отображение топ-10 игроков по монетам или алмазам (можно настраивать).

#### Логика:

Запрашивается топ-10 игроков. По умолчанию устанавливается сортировка по монетам. Её можно поменять, нажав на кнопку на странице лидеров.

Функция `getTopPlayers` отправляет запрос на бэкенд для получения топ-10 игроков. В параметры запроса добавляется `sort`: он ставится в положение `coins` либо `diamonds`. Если параметр передан не будет, то придёт топ-10 игроков по количеству монет.

Функция `prepareData` преобразует входной параметр (число) в более компактный вариант с приписками `K` - тысяча или `M`- миллион.

Функция `changeSort` меняет сортировку игроков.

Вместе с этим поставлена прослушка на значение сортировки. Как только оно меняется, то отправляется новый запрос на бэкенд. Хранить список топ-10 в хранилище фронтенда не имеет смысла, т.к. предполагается, что список будет достаточно часто меняться. В таком случае лучше запрашивать и показывать именно свежие данные пользователю.

## Entity-слой (слой сущностей)

Включает в себя сущность пользователя (`user`), который в свою очередь подразделяется ещё на части:

- Аккаунт
- Контейнеры
- Ежедневные награды
- Улучшения
- Модели

Помимо этого другие файлы:

1. `authorization.ts`:
   Выполняет логику авторизации. Принимает на вход объект с 6-ю полями:

- `login` - логин пользователя
- `password` - пароль пользователя
- `appDispatch` - нужен для работы с локальным хранилищем на Frontend-уровне
- `closeAuthWindow`- функция для закрытия окна авторизации
- `setError`- функция для установки ошибки в окно авторизации, если что-то пошло не так
- `setIsLoaded`- функция для установки загрузки, чтобы показывать пользователю статус загрузки, не допускать повторных запросов на бэкенд

На основе входных данных вызывает асинхронный код, куда передаёт дальше входные данные. Основная цель функции - отлавливание ошибок, которые будут показаны пользователю, и показ нужных уведомлений. Если вернулась 401-я ошибка, то значит, что неверный логин или пароль. Если вернулась 500-я ошибка, то пользователь увидит, что что-то не так на сервере.

2. `refreshAccessToken.ts`:

Выполняет логику по отправке запрос на бэкенд для обновления `JWT access` токена.
Сначала извлекает из переменных окружения `API_URL` и `CSRF-токен` из `Cookies`. Далее отправляет сам запрос на обновление токена с нужными заголовками.

3. `registration.ts`:

Выполняет логику по регистрации. Принимает на вход 3 параметра:

- `userData` - данные пользователя из формы регистрации
- `setError` - функция для установки ошибки в случае, если она где-то возникнет
- `closeRegisterWindow` - функция для закрытия окна регистрации

Основной целью функции является отправка запроса на регистрацию на бэкенд и отлавливание ошибок.

Данные пользователя из формы (`userData`) отправляются в теле запроса на бэкенд. Далее логин устанавливается к `LocalStorage` для того, чтобы потом, при открытии окна авторизации, пользователю не нужно было вводить его заново. Аналогичный способ с паролем очень рискованный, т.к. в таком случае его при желании достаточно легко будет украсть, поэтому во благо безопасности пользователя сохраняется только логин.

4. `useSyncOnUnload.ts`:

Функция для отправки данных о ресурсах пользователя в момент закрытия вкладки на бэкенд.

### Model:

Содержит в себе хранилище пользователя и `thunk-и`.

#### Хранилище пользователя:

Содержит в себе объект со следующими полями:

- `isAuthorized` - авторизован пользователь или нет
- `level` - уровень кликера
- `coinsPerMinute` - количество монет в минуту
- `coinsOnClick` - количество монет за клик
- `hasAutoClicker` - имеет ли автокликер (улучшение)
- `finances` - объект с полями
  - `coins` - количество монет у пользователя
  - `diamonds` - количество алмазов у пользователя
- `globals` - объект с глобальными данными пользователя
  - `id` - id пользователя
  - `nickname` - никнейм пользователя
  - `description` - описание пользователя
  - `dateOfRegister` - дата регистрации
  - `achievements` - список достижений
  - `canChangeNickname` - может ли бесплатно поменять никнейм
- `clicker` - объект с полями:
  - `upgrades` - массив купленных улучшений
- `account` - объект с полями:
  - `nicknamePrice` - объект с полями
    - `coins` - количество монет, сколько нужно для смены никнейма
    - `diamonds` - количество алмазов, сколько нужно для смены никнейма
  - `countNicknames` - количество раз, когда пользователь сменил никнейм
- `flags` - объект с полями:
  - `clickerData` - данные о кликере получены (флаг)
  - `accountData` - данные о пользователе получены (флаг)
- `dailyRewards` - массив с ежедневными наградами

Методы для управления состоянием хранилища:

1. `setIsAuthorized` - устанавливает флаг авторизации на основе параметра, который приходит
2. `setCoins` - устанавливает количество монет на основе параметра, который приходит
3. `addCoin` - добавляет к количеству монет количество монет за клик
4. `addCountOfCoins` - добавляет к количеству монет определённое количество (сколько придёт в параметре)
5. `addCountOfDiamonds` - добавляет алмазы на основе параметра, который приходит
6. `addCoinsInSecond` - добавляет количество монет, опираясь на количество монет в минуту
7. `addCoinsOnClick` - добавляет количество монет за клик на основе параметра, который приходит
8. `multiplyCoinsOnClick` - умножает текущее количество монет за клик на определённое количество, которое приходит в параметре
9. `setDiamonds` - устанавливает количество алмазов, которое приходит в параметре
10. `setCoinsPerMinute` - устанавливает количество монет в минуту на основе количества монет за клик
11. `addCountNicknames` - увеличивает количество раз, когда игрок сменил никнейм на 1
12. `setCanChangeNickname` - устанавливает флаг, может ли пользователь бесплатно поменять никнейм
13. `setDescription` - устанавливает описание
14. `setNickname` - устанавливает никнейм
15. `setNicknamePrice` - устанавливает цену смену никнейма
16. `setLevel` - устанавливает уровень кликера
17. `addUpgradeWithCount` - добавляет улучшение с полем количества (так, как они хранятся в массиве улучшений в хранилище)
18. `addOneUpgrade` - добавляет улучшение
19. `removeOneUpgrade` - убирает одно улучшение

### Подсущность - аккаунт (`/user/account`):

Включает в себя папку `thunk`, в которой содержатся `thunk-и`.

`Thunk-и` - отдельные функции, суть которых сводится к простой отправке запроса. Преимущество заключается в том, что можно прямо в локальном хранилище (при том не факт, что в одном, можно сразу в нескольких) поставить обработку ответа, который придёт. Это позволяет существенно "разгрузить" логику внутри отдельных пользовательских компонентов и переложить её на непосредственно хранилища, где и будет храниться информация.

Помимо их есть ещё 2 файла:

1. `activateReward.ts`:

Данная функция предназначена для отправки запроса на получение награды (через её `id`). В случае, если запрос пройдёт успешно, будет показано уведомление.

2. `processAccountData.ts`:

Функция принимает на вход объект из хранилища и ответ от сервера. Суть функции заключается в том, чтобы "раскидать" все данные, которые пришли с бэкенда по хранилищу. Требуется из-за разного способа именования переменных на фронтенде и бэкенде (нормальная ситуация).

#### Thunks:

1. `changeUserData.thunk.ts` - для отправки запроса на изменение данных пользователя (никнейм, описание)
2. `fetch.thunk.ts` - для отправки запроса на получение информации о пользователе
3. `setHasAchievement.thunk.ts` - для отправки запроса на начисление награды
4. `updateUserFinances.thunk.ts` - для отправки запроса на синхронизации ресурсов пользователя (монеты, алмазы)

### Подсущность - контейнер (`/user/containers`):

Содержит в себе папку `thunks` и файл `buyContainer.ts`.

Функция `buyContainer` выполняет функцию покупки контейнера. Принимает на вход `dispatch` (специальная функция для управления состоянием хранилища), объект с ресурсами пользователя, сам покупаемый контейнер, флаг (куплен контейнер за монеты или нет).

Сначала функция проверяет, что у пользователя действительно хватает ресурсов на покупку контейнера. Если их недостаточно, то функция останавливает покупку и выводит пользователю предупреждающее уведомление.

Если всё хорошо, то вызывается функция на отправку запроса (`sendRequestToBuyContainer`). Она уже отправляет сам запрос на бэкенд и отлавливает ошибки. Если запрос прошёл успешно, то устанавливает новые данные в хранилище.

#### Thunks:

1. `getContainers` - отправляет запрос на бэкенд для получения списка контейнеров.

### Подсущность - ежедневные награды (`/user/daily-rewards`):

Содержит в себе папки `model` и `thunks`. Первая содержит хранилище с ежедневными наградами, вторая - `thunk-и`

#### Model (хранилище ежедневных наград):

Содержит в себе объект со следующими параметрами:

- `data` - массив с ежедневными наградами
- `currentDay` - текущий день
- `allDays` - общее количество дней (14)
- `canGetReward` - может ли пользователь сейчас получить награду
- `hoursToNextReward` - количество часов до получения следующей награды

Есть 2 прослушки на запросы (`thunk-и`):

- `getDailyRewardsThunk` - устанавливает массив с ежедневными наградами
- `getCurrentRewardThunk` - сбрасывает флаг с возможностью получить награду сейчас и количество монет до следующей награды до 24.

#### Thunks

- `getCurrentRewardsDay.thunk.ts` - отправляет запрос на получение текущего дня для ежедневных наград (сколько дней подряд забирал ежедневные награды)
- `getCurrentReward.thunk.ts` - отправляет запрос на получение текущей ежедневной награды
- `getDailyRewards.thunk.ts` - отправляет запрос на получение массива с ежедневными наградами

### Подсущность - улучшения (`user/miglioramenti`)

Содержит в себе только `thunk-и`

#### Thunks:

- `activateMiglioramenti.thunk.ts` - отправляет запрос на активацию улучшения по его `id`.
- `buyMiglioramenti.thunk.ts` - отправляет запрос на покупку улучшения по его `id`.
- `getMiglioramenti.thunk.ts` - отправляет запрос на получение массива улучшений.

## Shared-слой (общий слой)

Содержит в себе всё то (логику, картинки, данные), что используется не в одном отдельном компоненте, а как минимум в двух.

Включает в себя следующие папки:

- `api`

Содержит единую систему обращения к API, т.е. к бэкенду. Нужна для удобства отправки запросов со всеми необходимыми заголовками (JWT access и CSRF токены, заголовок авторизации).

- `config`

Содержит конфигурационные файлы приложения: роутинг приложения (фронтенда) и роутинг бэкенда.

- `icons`

Содержит в себе иконки, изображения. Каждое из них используется минимум в двух компонентах.

- `portals`

Содержит в себе компонент портала, который принимает в качестве параметра другой компонент и выносит его в верхний уровень `DOM-дерева` приложения. Это нужно для лучшей семантики и `SEO-оптимизации`

- `types`

Содержит в себе файл с кастомными типами, которые используются во многих компонентах приложения.

### Api папка:

Содержит в себе 3 файла:

- `auth.ts`

Представляет собой объект с тремя методами:

1. logout - отправляет запрос на бэкенд. Говорит о том, что пользователь вышел из аккаунта
2. sendAuth - отправляет запрос на авторизацию. Принимает два параметра: логин и пароль, которые отправляет в параметрах к запросу.
3. sendRegister - отправляет запрос на регистрацию. Принимает два параметра: логин и пароль, которые отправляет в параметрах к запросу.

Эти три запроса были выделены в отдельный модуль, т.к. эти запросы требуют несколько иных заголовков в запросах, нежели остальные.

- `base.ts`

Содержит в себе api - глобальный объект, через который проходят почти все запросы на бэкенд. Он настраивает baseUrl (нужно в правильной обработке запроса, т.к. на локальной разработке всё идет через прокси, а в продакшен - напрямую на поддомен)

- `useAuthInterceptor.ts`

Модуль для отлавливания 401-х ошибок. Работает по следующему принципу: отслеживает все запросы. Если какой-либо пришёл с 401-й ошибкой (не авторизован), то проверяет сначала сам запрос: если он относится к авторизации или регистрации, то игнорирует. В противном случае шлёт запрос на обновление JWT access токена. В случае, если обновление токена прошло успешно, то идёт повторно тот запрос, который провалился с 401-й ошибкой. Этот модуль позволяет не думать о том, что токен может быть просроченным, во время написания логики. Это значительно облегчает разработку.

## Widget-слой (слой виджетов)

Включает в себя самостоятельные элементы приложения (всплывающие, открывающиеся окна, уведомления)

Содержит в себе 2 папки:

- `clicker-shop` - отвечает за логику и отрисовку всплывающего окна с покупкой улучшений.
- `pop-ups` - содержит компоненты всплывающих окон

### `Clicker-shop`:

Включает в себя папки `ui` (визуальная часть компонента) и `model` (логика компонента).

#### Логика:

Включает в себя 2 файла:

- `miglioramentiModel.ts`

Запрашивает данные из хранилища: авторизован ли пользователь, массив улучшений. Если массив улучшений пуст, то будет отправлен запрос на бэкенд для его получения.

- `miglioramentiSlice.ts`

Является частью локального хранилища. Хранит в себе только массив улучшений, который приходит с бэкенда.

Содержит 1 прослушку на запрос `getMiglioramenti`. Если он выполнился успешно, в параметре приходят данные, которые записываются в хранилище и дальше уже используются приложением.

### Pop ups (всплывающие окна):

Содержит в себе следующие папки:

#### `Auth` (авторизация):

Отвечает за логику и показ всплывающего окна с авторизацией

##### Логика:

Из `LocalStorage` достаётся и записывается в окно логин, если он есть. После этого, для общей безопасности, он сразу чистится в `LocalStorage`. То есть сам логин записывается в момент отправки формы с регистрацией, потом сразу же идёт открытие окна авторизации, где он считывается и удаляется. То есть сам логин в локальном хранилище данных хранится очень короткий отрезок времени (миллисекунды).

Содержит функции:

- `checkFields`: проверяет длину логина и пароля из формы. Если они меньше трёх символов каждое, то пользователю возвращается ошибка. Это ограничение сделано тоже в рамках безопасности.
- `closeAuthWindow`: закрывает окно авторизации, включает анимацию
- `openRegisterWindow`: закрывает окно авторизации и открывает окно регистрации
- `sendForm`: отправляет данные формы в функцию авторизации.

#### `ClickerImprovements` (улучшения для кликера):

Отвечает за отрисовку всплывающего окна с одноразовыми улучшениями.

##### Логика:

Запрашиваются данные об улучшениях пользователя. Далее они фильтруются и показываются только одноразовые (постоянные показываются на самой странице кликера, под фигуркой).

Функция `closeWindow` плавно закрывает окно.

#### `ContainerActivate` (Активация контейнера):

Отвечает за отрисовку всплывающего окна с активацией контейнера.

##### Логика:

Из хранилища достаются необходимые данные: список контейнеров, список улучшений, количество ключей, сам контейнер, который пользователь активировал.

Если список контейнеров или улучшений пуст, отправится запрос на бэкенд для их получения.

Функция `closeWindow` плавно закрывает окно.

Функция `activate` срабатывает в момент нажатия кнопки открытия контейнера. Она отправляет запрос об открытии контейнера на сервер и в случае успеха начисляет выпавшую награду, вычитает один ключ, если контейнер был открыт с ним. В случае, если возникла какая-либо ошибка, пользователю будет показано уведомление.

#### `Daily-rewards` (Ежедневные награды):

Отвечает за отрисовку всплывающего окна с ежедневной наградой.

##### Логика:

Из хранилища запрашивается информация: текущая награда, текущий день награды, возможность получить награду прямо сейчас.

Функция `addContainerByReward` добавляет игроку контейнер по его `id` (локально, только на фронтенде, чтобы не делать лишний запрос на бэкенд)

Функция `addMiglioramentiByReward` добавляет игроку улучшение по его `id`. Если улучшение постоянное, то сразу шлётся запрос на его активацию.

Функция `closeWindow` закрывает окно с ежедневной наградой и начисляет саму награду локально (бэкенд это делает тоже).

#### `Miglioramenti-click` (Активация одноразовых улучшений по клику):

Отвечает за отрисовку всплывающего окна с активацией одноразовых улучшений, которые требуют простого клика.

##### Логика:

Из хранилища запрашивается `id` улучшения, которое пользователь хочет активировать.

Функция `closeWindow` плавно закрывает окно.

Функция `activate` активирует само улучшение. Сначала шлётся запрос на активацию на бэкенд. Если он проходит успешно, то из хранилища убирается одно улучшение с этим `id`, начисляется награда, показывается уведомление с наградой. Если в момент активации произошла какая-либо ошибка, пользователю будет показано уведомление.

#### `Miglioramenti-other` (Активация других одноразовых улучшений):

Отвечает за активацию улучшений, для которых недостаточно одного клика.

Включает в себя локальное хранилище с активируемым улучшением.

##### Логика:

Из хранилища запрашиваются необходимые данные: активируемое улучшение, количество монет за клик.

Функция `closeWindow` плавно закрывает окно.

Функция `finish` скрывает кнопку, по которой пользователь должен кликать и получать доход.

Функция `calculateCountOfCoins` рассчитывает количество заработанных монет на основе количества кликов, количестве монет за клик, коэффициент умножения улучшения.

Функция `deactivateMiglioramenti` деактивирует улучшение, шлёт запрос на бэкенд.

Функция `activateMiglioramenti` активирует улучшение, шлёт запрос на бэкенд.

Функция `buttonHandle` срабатывает при старте активации улучшения. Ставит возможное количество кликов или запускает таймер (в зависимости от улучшения).

#### `Notifications` (уведомления):

Отвечают за показ списка уведомлений в правом нижнем углу.

Включает в себя папку с логикой и визуальным отображением компонента.

##### Логика:

Берёт список уведомлений из хранилища и просто показывает их списком.

Хранилище уведомлений:

Хранит в себе массив всех уведомлений.
Для управления хранилищем есть 3 метода:

1. `addNotification` - добавляет уведомление. Уведомление содержит тип (успех, предупреждение, ошибка) и сообщение.
2. `deleteLastNotification` - удаляет последнее уведомление из списка.
3. `deleteNotificationById` - удаляет сообщение по его id.

##### Менеджер уведомлений (`notificationManager`):

Является обёрткой над хранилищем уведомлений. Его суть заключается в том, чтобы добавлять уведомления и убирать их автоматически через 3 секунды.

#### `Register` (регистрация):

Содержит в себе компонент, отвечающий за отрисовку окна регистрации и папку с логикой.

##### Логика:

Функция `checkCanSend` проверяет, может ли пользователь сейчас отправить форму регистрации. Проверяется длина логина и пароля, совпадение полей "Пароль" и "Повторите пароль". Если что-то не так, то пользователю будет показана ошибка.

Функция `onChangeData` меняет данные в форме и записывает их в переменную (объект с полями). Принимает на вход объект с полями: ключ и значение.

Функция `openAuthWindow` открывает окно авторизации и закрывает окно регистрации

Функция `closeRegisterWindow` закрывает окно регистрации

Функция `sendForm` отправляет данные формы на бэкенд.

#### Tutorial (обучение):

Содержит единый компонент и логику для отображения текстовой информации для знакомства пользователя с тем или иным режимом игры.

##### Логика:

На вход компонент принимает объект с полями заголовка, текста, ключ к туториалу.

Функция `buttonHandle` закрывает окно.

## Feature-слой (слой фич)

Включает в себя небольшие составные компоненты, которые используются на страницах. Как правило, не содержат большой сложной логики.

Содержит в себе следующие папки:

### Clicker (кликер)

Содержит в себе следующие папки:

#### `Animal` (фигурка):

Отвечает за отрисовку фигурки и логику, связанную с ней

##### Логика:

Из хранилища достаются необходимые данные: уровень кликера, количество монет и алмазов, количество монет за клик, список улучшений пользователя.

Функция `addCoins` срабатывает при клике на фигурку. Она добавляет к тому количеству монет, которое есть сейчас. Кроме этого появляется количество монет, которое прибавилось, на том месте, куда кликнул пользователь. Для этого в компоненте есть массив с кликами.

#### `Infinity-miglioramenti` (постоянные улучшения):

Отвечает за отрисовку постоянных улучшений на главной странице под фигуркой.

Для этого берёт из хранилища все улучшения, фильтрует их по параметру: постоянное улучшение или нет, и показывает список.

#### `Miglioramenti` (улучшения):

Отвечает за показ отдельного улучшения в магазине.

##### Логика:

Из хранилища достаются данные: список улучшений, которые уже есть у пользователя, общий список улучшений. Если улучшение постоянное и оно уже есть у игрока, то он не сможет купить его второй раз.

Функция `buyImprovement` предназначена для покупки улучшений. Она принимает на вход `id` улучшения. Сначала проверяется, хватает ли монет у пользователя для покупки. Если да, то на бэкенд отправляется запрос на покупку улучшения по его `id`. Если всё прошло успешно, пользователю начисляется улучшение и вычитается то количество монет, сколько нужно было для покупки улучшения. Кроме этого пользователь увидит уведомление об успешной покупке. Если вдруг возникнет ошибка, пользователю тоже будет показано это через уведомление.

#### `Navbar` (навигационное меню):

Отвечает за отрисовку и бокового меню справа на главной странице. Не несёт в себе никакой логики, кроме нажатий на кнопки и показа соответствующих окон.

#### `One-time-miglioramenti` (одноразовые улучшения):

Отвечает за показ одноразового улучшения в отдельном окне, которое уже есть у пользователя.

Содержит только логику по нажатию на кнопку "Активировать" и открытием всплывающего окна с активацией улучшений.

#### `Progress-info` (Информационное меню)

Отвечает за показ актуальных данных: количества монет за клик и количество монет в минуту. Появляется только в мобильной версии приложения.

Не содержит логики.

### `Daily-rewards` (ежедневные награды)

Отвечает за показ отдельной ежедневной награды. Проверяет, была ли уже получена данная награда. Если да, то поверх награды отображается зелёная галочка, символизирующая о том, что награда уже была получена.

### `Notifications` (уведомления)

Отвечает за показ отдельного уведомления. Принимает в параметре тип сообщения и текст.

### `Randomizer` (рандомайзер)

Содержит в себе компоненты страницы "Рандомайзер":

#### `Container` (контейнер):

Отвечает за отображение контейнера

Запрашивает из хранилища ресурсы пользователя

Функция `preparePrice` принимает в параметре число и преобразует его в более компактный вид путём добавления "К".

#### `Container-rewards` (список наград из контейнера):

Компонент отвечает за отображение всех наград, которые могут выпасть из контейнера. Принимает в параметре массив наград.

Не содержит логики.

#### `Key` (ключ):

Компонент отвечает за отображение ключа с кнопкой покупки. Из хранилища запрашиваются данные о ресурсах пользователя: монеты и алмазы

Функция `buyOneKey` реализует покупку ключа. Сначала проверяется, что у пользователя достаточно ресурсов для покупки. Если это так, то на бэкенд уходит запрос на покупку. Если запрос прошёл успешно, из ресурсов пользователя вычтется цена ключа, покажется уведомление об успешной покупке. В случае ошибки пользователю будет показано уведомление.

#### `Own-container` (купленный контейнер):

Отвечает за отображение купленного контейнера. Отображает сам контейнер, его название, и кнопку открытия.

Функция `activate` отвечает за активацию конкретного контейнера. Принимает на вход один параметр: с ключом был открыт контейнер или нет. Если с ключом, то проверяется, что количество ключей больше нуля. Если у пользователя нет ключей, то он увидит предупреждающее уведомление. Если всё хорошо, то отправляется запрос на бэкенд для открытия контейнера.

### `User-account` (аккаунт пользователя):

Включает в себя компоненты из страницы личного кабинета пользователя:

#### `Exit-from-account` (выход из аккаунта):

Отвечает за отрисовку блока с кнопкой выхода из аккаунта.

При нажатии на кнопку выхода срабатывает функция `exitFromAccount`, которая отправляет запрос выхода на бэкенд (чтобы стереть токены в `Cookies`). Если всё успешно, то пользователю будет показано уведомление с успешным выходом из аккаунта. Если произошла какая-то ошибка, то пользователь увидит уведомление с ошибкой.

#### `User-description` (описание пользователя):

Отвечает за вывод блока с описанием пользователя в личном кабинете.

Принимает в параметрах функцию для обновления значения в родительском компоненте.

При каждом изменении описания вызывается функция `onDescriptionChange`, которая проверяет текст описания на длину. Если она больше 255, то лишнее обрезается (связано с ограничениями на бэкенде).

#### `User-nickname` (никнейм пользователя):

Отвечает за показ блока с никнеймом пользователя.

В параметрах принимает функцию для обновления никнейма.

Из хранилища берёт необходимые данные: никнейм, может ли бесплатно поменять никнейм, цену на изменение никнейма.

При каждом изменении никнейма срабатывает функция `onNicknameChange`, она проверяет длину. Если она больше 64, то лишняя часть обрезается (связано с ограничениями на бэкенде).

#### `User-registration-date` (дата регистрации пользователя):

Отвечает за отображение блока с датой регистрации в личном кабинете пользователя.

Берёт из хранилища дату регистрации и через функцию `formatDate` преобразует её из ISO-формата в формат ДД.ММ.ГГГГ.

Не содержит другой логики.

#### `User-rewards` (награды пользователя):

Отвечает за отображение блока с наградами пользователя в личном кабинете.

Принцип работы простой: берёт из хранилища список наград и выводит их.

# Бэкенд:

# Глобальная установка Backend-зависимостей

Чтобы подготовить среду для работы с серверной частью, выполните следующие шаги:

## 1. Установка Python

Перейдите на [официальный сайт Python.org](https://www.python.org/) и скачайте рекомендованную стабильную версию языка программирования `Python` 3.x для вашей ОС.

Запустите установщик:

- **Windows**: выберите опцию “Add Python to PATH” перед установкой.
- **macOS/Linux**: по умолчанию путь добавляется автоматически.

Проверьте установку в терминале:

```bash
python --version
```

или

```bash
python3 --version
```

## 2. Установка Poetry

`Poetry` — это современный инструмент управления зависимостями и виртуальными окружениями.

### 2.1. Быстрая установка

Выполните команду в терминале (работает на UNIX-подобных и Windows PowerShell):

```bash
curl -sSL https://install.python-poetry.org | python3 -
```

Или (PowerShell):

```powershell
(Invoke-WebRequest https://install.python-poetry.org -UseBasicParsing).Content | python -
```

### 2.2. Проверка установки

После завершения установки перезапустите терминал и выполните:

```bash
poetry --version
```

## 3. Установка зависимостей проекта

1. Перейдите в папку сервера:

   ```bash
   cd backend
   ```

2. Установите все зависимости из `pyproject.toml` и создайте виртуальное окружение:

   ```bash
   poetry install
   ```

3. После завершения установки внутри `.venv` будет создана виртуальная среда со всеми пакетами. Чтобы активировать её, выполните:

   ```bash
   poetry shell
   ```

# Документация по Backend-проекту

Технологии: Flask, Flask-SQLAlchemy, Flask-Migrate, Flask-CORS, Flask-JWT-Extended, Pydantic, python-dotenv, PostgreSQL

---

## 1. Entry-point и конфигурация

- **ClickZone.py**
  Главный скрипт запуска приложения:

  - Загружает конфиг из `config.py` (DB URI, JWT, CORS и т.д.).
  - Вызывает `create_app()` (factory) и запускает сервер.

- **config.py**
  Чтение `.env` через `python-dotenv`, хранит:

  - `SQLALCHEMY_DATABASE_URI`
  - `JWT_SECRET_KEY`
  - `CORS_ORIGINS`
  - Параметры Redis.

- **boot.sh**
  Скрипт инициализации контейнера:

  - `poetry install`, миграции `alembic upgrade head`, запуск Gunicorn.

- **Dockerfile**, **docker-compose.yml**
  Контейнеризация приложения и БД/Postgres/Redis.

---

## 2. Миграции и база данных

- **migrations/\***
  Alembic:

  - `env.py`, `alembic.ini`.
  - Папка `versions/` с SQL‑скриптами изменений схемы.

---

## 3. Конфигурационные файлы проекта

- **pyproject.toml**, **poetry.lock**
  Управление зависимостями (Poetry).

- **.env.example**
  Шаблон переменных окружения.

---

## 4. Веб-приложение (слой `app`)

### 4.1 Инициализация приложения

```python
# app/__init__.py

logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] #%(levelname)-8s %(filename)s:%(lineno)d - %(name)s - %(message)s'
)
logger = logging.getLogger(__name__)

db = SQLAlchemy()
migrate = Migrate()
cors = CORS()
jwt = JWTManager()
redis = redis.Redis(
    host=os.environ.get('REDIS_HOST'),
    decode_responses=True
)

def create_app(config_class=Config):
    """
    Factory-функция для создания и настройки Flask-приложения.
    """
    app = Flask(__name__)
    app.config.from_object(config_class)

    # Инициализация расширений
    db.init_app(app)
    migrate.init_app(app, db)
    jwt.init_app(app)
    cors.init_app(app,
        supports_credentials=True,
        origins=app.config.get('CORS_ORIGINS'),
        expose_headers=['Authorization','X-CSRFToken','X-CSRF-TOKEN'],
    )

    # Обработчик кастомного исключения
    @app.errorhandler(InsufficientMoneyError)
    def handle_insufficient_funds(error):
        return jsonify({'msg': str(error)}), 402

    # Регистрация блюпринтов
    from app.auth import bp as auth_bp
    app.register_blueprint(auth_bp, url_prefix='/api/auth')
    from app.main import bp as main_bp
    app.register_blueprint(main_bp, url_prefix='/api')
    from app.profile import bp as profile_bp
    app.register_blueprint(profile_bp, url_prefix='/api/profile')
    from app.daily_rewards import bp as daily_reward_bp
    app.register_blueprint(daily_reward_bp, url_prefix='/api/daily-rewards')
    from app.upgrades import bp as upgrades_bp
    app.register_blueprint(upgrades_bp, url_prefix='/api/upgrades')
    from app.containers import bp as containers_bp
    app.register_blueprint(containers_bp, url_prefix='/api/containers')

    return app
```

### 4.2 Модели базы данных

- SQLAlchemy-модели: User, Upgrade, UserUpgrade, Achievement, UserAchievement, Container, ContainerReward, UserContainer, DailyReward.

#### 4.2.1 Upgrade & UserUpgrade

- `class Upgrade(db.Model)` — таблица улучшений:

  - Поля: `id, name, description, upgrade_type, effect_type, image_path, cost_coins, cost_diamonds, multiplier`
  - Метод `to_dict()` даёт список словарей для API.

- `class UserUpgrade(db.Model)` — связь пользователь ↔ улучшение:

  - PK: `(user_id, upgrade_id)`
  - Поля: `quantity, active`
  - Валидатор `@event.listens_for` запрещает `quantity != 1` для перманентных улучшений.

#### 4.2.2 Achievement & UserAchievement

- `class Achievement(db.Model)` — таблица наград (`id, name, condition`).
- `class UserAchievement(db.Model)` — связь пользователь ↔ награда.

#### 4.2.3 User

- `class User(db.Model)` — основной пользователь:

  - Атрибуты профиля, балансы, параметры клика и ежедневных наград.
  - Методы:

    - `set_password()`, `check_password()`
    - `achievements` (property) — возвращает список всех наград с флагом получения.
    - `nickname_change_cost`, `user_dto()`, `is_streak_broken()`, `can_claim_reward()`, `get_next_reward_info()`.

#### 4.2.4 Сценарий транзакций

- `class DBSessionManager` — контекстный менеджер для автоматического `commit()` или `rollback()`.

#### 4.2.5 Rewards

- `class DailyReward(db.Model)` — настройки ежедневных наград + сериализация.

#### 4.2.6 Containers

- `class Container(db.Model)` — справочник контейнеров + методы `to_dict*()` и `get_reward(use_key)`.
- `class ContainerReward(db.Model)` — содержимое контейнера (модели отношений).
- `class UserContainer(db.Model)` — связь пользователь ↔ контейнер (PK + `quantity`).

---

## 5. Слой ошибок и Json Web Token

### 5.1 Custom Errors

```python
# app/errors/custom_errors.py
class InsufficientMoneyError(Exception):
    """Недостаточно средств для совершения операции"""
    pass
```

**Описание:**

- Исключение `InsufficientMoneyError` выбрасывается, когда пользователь пытается выполнить операцию без достаточного количества монет или алмазов.

### 5.2 Обработчики ошибок

**Использование:**
В `app/__init__.py` через декоратор `@app.errorhandler(...)` регистрируется `InsufficientMoneyError`
Вызов `validation_error` и `default_error` для Pydantic и неожиданных исключений в `@bp.route(...)`.

##№ 5.3 Обработчики Json Web Token

**Использование:**
В обработке jwt_required - для получения данных по API нужен jwt токен, если он истёк, повреждён, отозван, пропущен генерируются соответствующие ошибки.

---

## 6. Слой API (блюпринты)

Каждый модуль API оформлен отдельным Blueprint. Описание слоёв:

### 6.1 Слой `auth` (аутентификация и сессии)

Пакет `auth` отвечает за все процессы, связанные с регистрацией, входом и выходом пользователей. Здесь обрабатываются HTTP-запросы, выполняется валидация входных данных через Pydantic, создаются и проверяются JWT-токены, сохраняются и удаляются куки.

```text
app/auth/
├── routes.py           # регистрация, логин, логаут
└── validators/         # Pydantic-схемы форм
    ├── registration_form.py
    └── login_form.py
```

#### Описание ключевых маршрутов

- **`POST /api/auth/registration`**

  1. Парсит JSON через `RegistrationForm` (валидирует длину полей и уникальность логина).
  2. Создаёт новый `User`, начисляет стартовые ресурсы, сохраняет в БД.
  3. Возвращает DTO пользователя (ID и username).

- **`POST /api/auth/login`**

  1. Парсит JSON через `LoginForm` (проверяет существование и пароль).
  2. Формирует ответ: собирает информацию об апгрейдах и контейнерах пользователя.
  3. Генерирует JWT-токены (`access` и `refresh`), сохраняет JTI `refresh_token` в Redis.
  4. Устанавливает HTTP-only куки (`set_access_cookies`, `set_refresh_cookies`).

- **`POST /api/auth/logout`**

  1. Требует валидный `access_token` (`@jwt_required()`).
  2. Очищает куки с токенами (`unset_jwt_cookies`).
  3. Возвращает сообщение об успешном выходе.

#### Validators (Pydantic)

```python
class RegistrationForm(BaseModel):
    login: str = Field(..., min_length=4)
    password: str = Field(..., min_length=4)
    @field_validator('login')
    def unique_login(cls, v): ...
```

```python
class LoginForm(BaseModel):
    login: str = Field(..., min_length=4)
    password: str = Field(..., min_length=4)
    @model_validator(mode='after')
    def check_credentials(self): ...
```

- **`RegistrationForm`** (`validators/registration_form.py`)
  Содержит поля `login` и `password` с минимальной длиной 4.
  Валидатор `validate_login` проверяет, что логин ещё не занят.

- **`LoginForm`** (`validators/login_form.py`)
  Содержит поля `login` и `password` с минимальной длиной 4.
  Валидатор `check_credentials` после базовой проверки проверяет корректность пары логин/пароль и выдаёт ошибку при неверных данных.

---

### 6.2 Слой `containers` (покупка и открытие контейнеров)

Пакет `containers` управляет списком контейнеров, покупкой и получением наград из них. Все маршруты требуют авторизации (`@jwt_required()`).

```text
app/containers/
├── routes.py           # GET /, POST / (покупка), POST /claim (открытие)
└── validators/         # Pydantic-схемы для операций
    ├── container_form.py
    └── id_container_form.py
```

#### Основная логика в `routes.py`

- **`GET /api/containers/`**
  Возвращает список всех контейнеров (`Container.to_dict_all()`).

- **`POST /api/containers/`**

  1. Валидация входных данных через `ContainerForm` (проверка id и соответствия стоимости).
  2. Проверка баланса пользователя (монеты/алмазы).
  3. Списание средств и добавление `UserContainer` (увеличение `quantity` или создание новой записи).
  4. Возврат обновлённого баланса.

- **`POST /api/containers/claim`**

  1. Валидация через `IdContainerForm` (существование контейнера и наличие у пользователя).
  2. Генерация награды `container.get_reward(use_key)` (монеты, алмазы, ключи, улучшения, контейнеры).
  3. Начисление ресурсов или улучшений пользователю:

     - Добавление монет/алмазов/ключей.
     - Добавление или обновление `UserUpgrade` для улучшений (с учётом `permanent` vs `consumable`).
     - Добавление `UserContainer` для выпавших контейнеров.

  4. Уменьшение `quantity` открываемого контейнера и списание ключа (если `use_key=True`).
  5. Возврат информации о награде.

#### Validators (Pydantic)

- **`ContainerForm`** (`validators/container_form.py`)
  Содержит поля `id`, `cost_coins`, `cost_diamonds`.
  Валидатор проверяет:

  - Существование контейнера.
  - Соответствие одной из цен реальной стоимости.

- **`IdContainerForm`** (`validators/id_container_form.py`)
  Содержит поля `id` и `use_key`.
  Валидатор проверяет:

  - Существование контейнера.
  - Наличие контейнера у пользователя.

---

### 6.3 Слой `daily_rewards` (ежедневные награды)

Пакет `daily_rewards` предоставляет функционал просмотра и получения ежедневных наград. Пользователь может проверить статус награды, получить список наград и запросить выдачу текущей.

```text
app/daily_rewards/
└── routes.py           # GET /, GET /status, POST /claim
```

#### Ключевые маршруты

- **`GET /api/daily-rewards/`**
  Возвращает все доступные награды за 14 дней (метод `DailyReward.to_dict_all()`).

- **`GET /api/daily-rewards/status`**
  Получает у текущего пользователя (`get_current_user()`) информацию о:

  - Текущем дне награды (`current_reward_day`).
  - Доступности награды и времени до следующей (метод `user.get_next_reward_info()`).

- **`POST /api/daily-rewards/claim`**

  1. Проверяет, что награда существует и пользователь может её получить (`is_streak_broken()`, `can_claim_reward()`).
  2. Начисляет монеты и алмазы (`reward.coins`, `reward.diamonds`).
  3. Для пользовательских наград (`reward.custom`):

     - Если путь содержит `/miglioramenti/`, добавляет `UserUpgrade`.
     - Иначе добавляет `UserContainer` для кастомных контейнеров.

  4. Обновляет `current_reward_day` (циклически от 1 до 14) и `last_reward_claimed_at`.
  5. Возвращает ID выданной награды и обновлённые ресурсы пользователя.

---

### 6.4 Слой `main` (гейм-логика: клики, баланс, достижения и топ)

Пакет `main` содержит маршруты для игровых операций: обновление токена, синхронизация ресурсов, кликер-логика, получение достижений, ключей и статистики игроков.

```text
app/main/
├── routes.py           # refresh, check-auth, resource-sync, clicker, achievements, keys, stats
├── services/
│   └── calculate_max_click_coins.py  # Логика расчёта максимального дохода за период
└── validators/
    ├── ResourceForm        # Синхронизация баланса
    ├── IdAchievementForm   # Получение достижения по id
    └── AmountKeyForm       # Покупка ключей
```

#### JWT Загрузка пользователя

- **`@jwt.user_lookup_loader`** — загружает объект `User` по `sub` из токена.

#### Основные маршруты

- **`POST /api/refresh`**
  Обновляет access токен по валидному refresh токену, устанавливает новую куку.

- **`POST /api/check-auth`**
  Проверяет существование пользователя, возвращает DTO аналогично `/login`.

- **`POST /api/resource-sync`**

  1. Валидирует данные через `ResourceForm`.
  2. Вычисляет допустимый максимум дохода за 3 мин (`calculate_max_click_coins`).
  3. Синхронизирует баланс, если изменения в пределах лимита.

- **`POST /api/achievements`**

  1. Валидирует `IdAchievementForm`.
  2. Проверяет условие достижения (на основе `form.id`).
  3. Добавляет `UserAchievement` и возвращает статус:

     - `200 OK` при успешном присвоении.
     - `400 Bad Request` при невыполненных условиях.

- **`POST /api/keys`**

  1. Валидирует через `AmountKeyForm`.
  2. Начисляет ключи и списывает монеты (цена из `Config.KEYS_PRICE`).

- **`GET /api/get-top-players`**
  Возвращает топ-10 игроков по монетам или алмазам (параметр `sort`).

- **`GET /api/get_player_info`**
  Возвращает публичную информацию о пользователе по `id`:
  никнейм, описание, достижения, дата регистрации.

---

### 6.5 Слой `profile` (изменение и получение профиля)

Пакет `profile` отвечает за редактирование данных пользователя и получение его текущих данных.

```text
app/profile/
├── routes.py             # POST /edit_profile, POST /me
└── validators/
    └── edit_profile_form.py  # Pydantic-схема для редактирования профиля
```

#### Ключевые маршруты

- **`POST /api/profile/edit_profile`**

  1. Валидирует JSON через `EditProfileForm` (длина `name`, уникальность имени, корректность цены смены).
  2. Обновляет поле `about_me`.
  3. Если изменился `name`:

     - Если `can_change_name=True`, меняет имя бесплатно.
     - Иначе проверяет ресурсы (`coins`, `diamonds`) через `nickname_change_cost`.
     - Списывает стоимость и увеличивает `changes_number`.

  4. Возвращает сообщение, новую цену смены имени и текущие ресурсы.

- **`POST /api/profile/me`**
  Возвращает информацию о текущем пользователе:

  - `nickname`, `about_me`
  - Ресурсы (`coins`, `diamonds`)
  - Достижения (`achievements`)
  - Флаги `can_change_name`, `changes_number`, `nickname_price`
  - Дата регистрации (`timestamp`)

#### Validator (`EditProfileForm`)

- Поля:

  - `name: str` (min_length=1)
  - `about_me: str`
  - `nickname_price: dict[str,int]`

- `validate_name`: проверяет, что имя свободно или совпадает с текущим.
- `validate_nickname_price`: сравнивает присланную цену с актуальной `nickname_change_cost`.

---

### 6.6 Слой `upgrades` (покупка и активация улучшений)

Пакет `upgrades` позволяет получить список улучшений, купить их и активировать одноразовые и постоянные эффекты.

```text
app/upgrades/
├── routes.py             # POST /, GET /, POST /activate-upgrade, POST /deactivate-upgrade
└── validators/
    ├── upgrade_form.py       # Цена и ID при покупке
    └── id_upgrade_form.py    # ID при активации/деактивации
```

#### Основные маршруты

- **`GET  /api/upgrades/`**
  Возвращает каталог всех улучшений (`Upgrade.to_dict()`).

- **`POST /api/upgrades/`**

  1. Валидация через `UpgradeForm` (проверка стоимости и существования).
  2. Проверка уникальности для `permanent`, баланса пользователя.
  3. Списание `coins`/`diamonds` и добавление/увеличение `UserUpgrade`.
  4. Возврат нового баланса.

- **`POST /api/upgrades/activate-upgrade`**

  1. Валидация через `IdUpgradeForm`.
  2. Для `consumable` улучшений: рандомная награда (монеты/алмазы) c уменьшением `quantity`.
  3. Для `permanent` и спецэффектов: изменение `base_per_click`, установка `active=True` и изменение `multiplier`.
  4. Обновление `base_per_minute`, если есть активный апгрейд 14 (каждый час).
  5. Возврат сообщения, обновлённого баланса и количества.

- **`POST /api/upgrades/deactivate-upgrade`**

  1. Валидация `IdUpgradeForm`.
  2. Проверка, что улучшение поддерживает деактивацию.
  3. Установка `active=False`, уменьшение/удаление `UserUpgrade`.
  4. Возврат статуса деактивации.

#### Validators (Pydantic)

- **`UpgradeForm`** (`validators/upgrade_form.py`)
  Поля: `id`, `cost_coins`, `cost_diamonds`.
  Проверка, что цена соответствует модели `Upgrade`.

- **`IdUpgradeForm`** (`validators/id_upgrade_form.py`)
  Поле: `id`.
  Проверка существования апгрейда и наличия у пользователя.
